fullnameOverride: ""
nameOverride: ""
replicas: 1
image:
  repository: quay.io/keycloak/keycloak
  tag: "26.5.3"
  digest: ""
  pullPolicy: IfNotPresent
imagePullSecrets: []
hostAliases: []
enableServiceLinks: true
podManagementPolicy: OrderedReady
updateStrategy: RollingUpdate
restartPolicy: Always
serviceAccount:
  create: true
  allowReadPods: false
  name: ""
  annotations: {}
  labels: {}
  imagePullSecrets: []
  automountServiceAccountToken: true
rbac:
  create: false
  rules: []
podSecurityContext:
  fsGroup: 1000
securityContext:
  runAsUser: 1000
  runAsNonRoot: true
extraInitContainers: ""
skipInitContainers: false
extraContainers: ""
lifecycleHooks: |
terminationGracePeriodSeconds: 60
clusterDomain: cluster.local
command:
  - "/opt/keycloak/bin/kc.sh"
args:
  - "start"
extraEnv: |
  - name: KEYCLOAK_ADMIN
    value: admin
  - name: KEYCLOAK_ADMIN_PASSWORD
    valueFrom:
      secretKeyRef:
        name: keycloak-helm
        key: admin-password
  - name: KC_HOSTNAME
    value: keycloak.apps.k8s.enros.me
  - name: KC_HOSTNAME_STRICT
    value: "false"
  - name: KC_HOSTNAME_STRICT_HTTPS
    value: "false"
extraEnvFrom: ""
priorityClassName: ""
affinity: |
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchLabels:
            {{- include "keycloak.selectorLabels" . | nindent 10 }}
          matchExpressions:
            - key: app.kubernetes.io/component
              operator: NotIn
              values:
                - test
        topologyKey: kubernetes.io/hostname
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchLabels:
              {{- include "keycloak.selectorLabels" . | nindent 12 }}
            matchExpressions:
              - key: app.kubernetes.io/component
                operator: NotIn
                values:
                  - test
          topologyKey: topology.kubernetes.io/zone
topologySpreadConstraints:
nodeSelector: {}
tolerations: []
podLabels: {}
podAnnotations: {}
livenessProbe: |
  httpGet:
    path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/health/live'
    port: '{{ .Values.http.internalPort }}'
    scheme: '{{ .Values.http.internalScheme }}'
  initialDelaySeconds: 0
  timeoutSeconds: 5
readinessProbe: |
  httpGet:
    path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/health/ready'
    port: '{{ .Values.http.internalPort }}'
    scheme: '{{ .Values.http.internalScheme }}'
  initialDelaySeconds: 10
  timeoutSeconds: 1
startupProbe: |
  httpGet:
    path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/health'
    port: '{{ .Values.http.internalPort }}'
    scheme: '{{ .Values.http.internalScheme }}'
  initialDelaySeconds: 15
  timeoutSeconds: 1
  failureThreshold: 60
  periodSeconds: 5
resources: {}
extraVolumes: ""
volumeClaimTemplates: ""
extraVolumeMounts: ""
extraPorts: []
podDisruptionBudget: {}
statefulsetAnnotations: {}
statefulsetLabels: {}
secrets: {}
service:
  annotations: {}
  labels: {}
  type: ClusterIP
  loadBalancerIP: ""
  httpPort: 80
  httpNodePort: null
  httpsPort: 8443
  httpsNodePort: null
  extraPorts: []
  loadBalancerSourceRanges: []
  # See https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
  externalTrafficPolicy: "Cluster"
  # See https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-userspace
  sessionAffinity: ""
  sessionAffinityConfig: {}
serviceHeadless:
  annotations: {}
  extraPorts: []
# (see: https://gateway-api.sigs.k8s.io/guides/)
httpRoute:
  enabled: false
  labels: {}
  annotations: {}
  servicePort: 80
  parentRefs:
    - name: gateway
      sectionName: http
  hostnames:
    - chart-example.local
  rules:
    - matches:
      - path:
          type: PathPrefix
          value: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/'
  console:
    enabled: false
    labels: {}
    annotations: {}
    parentRefs:
      - name: gateway
        sectionName: http
    hostnames:
      - chart-example.local
    rules:
      - matches:
        - path:
            type: PathPrefix
            value: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/admin'
ingress:
  enabled: true
  ingressClassName: "traefik"
  servicePort: http
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    traefik.ingress.kubernetes.io/router.tls: "true"
    traefik.ingress.kubernetes.io/router.tls.certresolver: letsencrypt
    cert-manager.io/cluster-issuer: letsencrypt-production
    kubernetes.io/tls-acme: "true"
    traefik.ingress.kubernetes.io/router.middlewares: keycloak-keycloak-headers@kubernetescrd
  labels: {}
  rules:
    - host: 'keycloak.apps.k8s.enros.me'
      paths:
        #- path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/'
        - path: /
          pathType: Prefix
  tls:
    - hosts:
        - keycloak.apps.k8s.enros.me
      secretName: keycloak-tls
  console:
    enabled: false
    ingressClassName: ""
    annotations: {}
    labels: {}
    rules:
      -
        host: '{{ .Release.Name }}.keycloak.example.com'
        paths:
          - path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/admin'
            pathType: Prefix
    tls: []
networkPolicy:
  enabled: false
  labels: {}
  extraFrom: []
  egress: []
route:
  enabled: false
  path: /
  annotations: {}
  labels: {}
  host: ""
  tls:
    enabled: true
    insecureEdgeTerminationPolicy: Redirect
    termination: edge
dbchecker:
  enabled: false
  image:
    repository: docker.io/busybox
    tag: 1.32
    pullPolicy: IfNotPresent
  securityContext:
    allowPrivilegeEscalation: false
    runAsUser: 1000
    runAsGroup: 1000
    runAsNonRoot: true
  resources:
    requests:
      cpu: "20m"
      memory: "32Mi"
    limits:
      cpu: "20m"
      memory: "32Mi"
database:
  existingSecret: "keycloak-helm"
  existingSecretKey: "postgres-user-password"
  vendor: postgres
  hostname: postgresql.postgresql.svc.cluster.local
  port: 5432
  database: keycloak
  username: keycloak
cache:
  stack: default
proxy:
  enabled: true
  mode: forwarded
  http:
    enabled: true
metrics:
  enabled: true
health:
  enabled: true
http:
  relativePath: "/auth"
  internalPort: http-internal
  internalScheme: HTTP
serviceMonitor:
  enabled: false
  namespace: ""
  namespaceSelector: {}
  annotations: {}
  labels: {}
  interval: 10s
  scrapeTimeout: 10s
  relabelings: []
  metricRelabelings: []
  path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/metrics'
  port: '{{ .Values.http.internalPort }}'
  scheme: ""
extraServiceMonitor:
  enabled: false
  namespace: ""
  namespaceSelector: {}
  annotations: {}
  labels: {}
  interval: 10s
  scrapeTimeout: 10s
  relabelings: []
  metricRelabelings: []
  path: '{{ tpl .Values.http.relativePath $ | trimSuffix "/" }}/metrics'
  port: '{{ .Values.http.internalPort }}'
  scheme: ""
prometheusRule:
  enabled: false
  namespace: ""
  annotations: {}
  labels: {}
  rules: []
autoscaling:
  enabled: false
  labels: {}
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Pods
          value: 1
          periodSeconds: 300
test:
  enabled: false
  image:
    repository: docker.io/seleniarm/standalone-chromium
    tag: "117.0"
    pullPolicy: IfNotPresent
  podSecurityContext:
    fsGroup: 1000
  securityContext:
    runAsUser: 1000
    runAsNonRoot: true
  # See https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies
  deletionPolicy: before-hook-creation
extraManifests: []
